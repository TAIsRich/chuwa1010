### 2. what is selenium?

- Selenium is User-behavior simulation.
It simulate interactive user behavior to test the application


### 3. what is cucumber?


- Cucumber is a testing tool that supports Behavior Driven Development (BDD)
it is written in the "Given, When and Then" format



### 4. what is JMeter?


- JMeter is a testing tool used for analyzing and measuring the performance of different software services and products.
- It is used to perform performance testing, functional testing, and load testing of web applications.



### 5. what is unit-test?


- Unit testing involves the testing of each unit or an individual component of the software application.
- The purpose is to validate that each unit of the software code performs as expected.
- Unit testing is done during develpment of an application by the developers
- Unit may be a an individual function, method, procedure, module and object.



### 6. What is the lifecircle of Junit?


The complete lifecycle of a test case can be seen in three phases with the help of annotations.

Setup: 
- This phase puts the the test infrastructure in place. 
- JUnit provides class level setup (@BeforeAll) and method level setup (@BeforeEach). 
- Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.

Test Execution: 
- In this phase, the test execution and assertion happen. 
- The execution result will signify a success or failure.

Cleanup: 
- This phase is used to cleanup the test infrastructure setup in the first phase. 
- Just like setup, teardown also happen at class level (@AfterAll) and method level (@AfterEach).



### 7. Is @BeforeAll method should be Class level(static)?


-Yes.
- @BeforeAll and @AfterAll annotations should be called only once in the entire tests execution cycle. 
So they must be declared static at class level.



### 8. What is Mockito? and what is its limitations?


- Mockito is a Java-based mocking framework used for unit testing 
- it creates a mock object that returns a dummy data and avoids external dependencies.

Some limitations of the mockito are:
- It cannot mock constructors or static methods.
- It requires Java version 6 plus to run.
- It also cannot mock equals(), hashCode() methods.
- VM mocking is only possible on VMs that are supported by Objenesis.



### 9. What is @Mock and what is @InjectMocks?


- @Mock is used to create mocks that are needed to support the testing of the class to be tested. 
- @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock annotations into this instance.


### 10. What is the stubbing?


- A stub is a small piece of code that takes the place of another component during testing. 
- The stubbing approach is easy to use and involves no extra dependencies for the unit test.
- It always returns the predefined output regardless of the input and you can run tests even if the other components are not working yet.



### 11. what is Mockito ArgumentMatchers


- Argument matchers are mainly used for performing flexible verification and stubbing in Mockito. 
- It extends ArgumentMatchers class to access all the matcher functions. 
- In some cases, we need more flexibility during the verification of argument values, so we should use argument matchers instead of equal() method. 



### 12. what is Hamcrest Matchers


- Hamcrest is a framework that assists writing software tests in  Java
- It supports creating customized assertion matchers ('Hamcrest' is an anagram of 'matchers'), allowing match rules to be defined declaratively.

e.g.
```
List<Integer> num = Arrays.asList(99,123,45,148,33);  
          
assertThat( num, hasSize(5));  
assertThat( num, hasItems(99,45));  

assertThat( num, everyItem(greaterThan(20)));  
assertThat( num, everyItem(greaterThanOrEqualTo(33)));  
assertThat( num, everyItem(lessThan(150)));  
```


### 13. do you know @spy? what is difference between @spy and @Mock?


- @Mock will mock everything.

- @Spy is used for creating spy objects. It allows us to call the normal methods of the real object.
- @Spy also allows you to partially mock objects
- In spying, the real object remains unchanged, and we just spy some specific methods of it.  In other words, we take the existing (real) object and replace or spy only some of its methods.

