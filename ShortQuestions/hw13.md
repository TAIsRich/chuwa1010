**2**

Spring: Spring is a lightweight open-source Java development framework. It provides a comprehensive programming and configuration model for developing enterprise level Java applications. It focuses on several areas of application development and provides a wide range of features.

SpringBoot:Spring Boot is an extension of Spring, which eliminates the boilerplate configurations required for setting up a Spring application. Featuring default codes and annotation based configuration, Spring Boot enables a faster and more efficient development ecosystem.

Since Spring Boot is built on top of Spring, it offers all the features and benefits of Spring. Spring Boot aims to reduce code length and provides developers with the easiest way to build an application.

Benefit: doesn't require XML configuration, embeds Tomcat, Jetty and Undertow directly, no need to deploy WAR files, easier to launch, easier management and customization

**3**

IOC: short for inversion of control, is a principle in software engineering which transfers the control of objects or portions of a program to a container or framework. IoC enables a framework to take control of the flow of a program and make calls to our custom code

DI: Dependency Injection, a pattern we can use to implement IoC, where the control being inverted is setting an object's dependencies. By using DI, The item does not need to specify the implementation of the item.

**4**

@CompnonentScan: define where the spring need to scan the bean definations and generate the beans. could direct Spring to search for components in the
path specified.

**5**

in annotation: using basePackages

```Java
@Configuration
@ComponentScan(basePackages = {"com.chuwa.springbasic"})
```

in xml:

```Java
<context:component-scan base-package="com.chuwa.springbasic"/>
        <bean id="dataNucleusChuwaNoComponent"  class="com.chuwa.springbasic.components.impl.DataNucleusChuwaNoComponent"></bean>
```

**6**

A single @SpringBootApplication annotation can be used to enable those three features:

@EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism

@ComponentScan: enable @Component scan on the package where the application is located 

@Configuration: allow to register extra beans in the context or import additional configuration classes

**7**

class level: using @Component, @Service, @Repository, @Controller

method level: @Bean (used with @Configuration) together

xml: 
```Java
<bean id="dataNucleusChuwaNoComponent"
class="com.chuwa.springbasic.components.impl.DataNucleusChuwaNoComponent"></bean>
```

**8**

@Component: The default bean name will be method name.

@Bean: could be specified by following name. E: the bean name is a1Bean

```Java
@Bean("a1Bean")
	public BeanA getBeanA() {
		BeanA beanA = new BeanA();
		beanA.setName("Bean A");
		return beanA;
	}
```

**9**

difference between @component and @service, @repository: no difference in annotating, they just represent different service levels.

@Component is a generic stereotype for any Spring-managed component. @Service annotates classes at the service layer. @Repository annotates classes at the persistence layer, which will act as a database repository.

**10**

@Autowired(including @Qualifier, @Primary), @Resource, @Inject

**11**

Field injection, constructor injection, setter injection. Constructor injection is the best because it is the most safe way.

**12**

Use @Primary to specify.

If without primary, @Qualifier would be used and the priority order is @Qualifier > @Primary > By Name > throw exception

**13**

difference between BeanFactory and ApplicationContext: The BeanFactory is the most basic version of IOC containers, and the ApplicationContext extends the features of BeanFactory. BeanFactory loads beans on-demand(lazy loading), while ApplicationContext loads all beans at startup(eager loading). Thus, BeanFactory is lightweight as compared to ApplicationContext. BeanFactory supports only Singleton and Prototype bean scopes while ApplicationContext supports all types of bean scopes such as Singleton, Prototype, Request, Session etc. BeanFactory does not support Annotations. In Bean Autowiring, we need to configure the properties in XML file only. But ApplicationContext supports Annotation based configuration in Bean Autowiring.

**14**

Spring Bean Scopes allows us to have more granular control of the bean instances creation.

Singleton: only one instance of the spring bean will be created for the spring container. This is the default spring bean scope. 

Prototype: A new instance will be created every time the bean is requested from the spring container.

request: This is same as prototype scope, however it’s meant to be used for web applications. A new instance of the bean will be created for each HTTP request.

session: A new bean will be created for each HTTP session by the container.

global-session: This scopes a bean definition to a global HTTP session

**15**

```JAVA
<beans>
	<bean id="employee"  class="chuwa.Employee"></bean>
</beans> 
```

```JAVA
<beans>
	<import resource="employee.xml"/>
   
  	<bean id="employee" class="chuwa.Employee"></bean>
</beans> 
```

```JAVA
<beans>
	<import resource="employee.xml"/>
   
  	<bean id="employee" class="chuwa.Employee"></bean>
</beans> 
```

a class TextEditor that can only be dependency-injected with constructor injection.

```Java
<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <!-- Definition for textEditor bean -->
   <bean id = "textEditor" class = "com.tutorialspoint.TextEditor">
      <constructor-arg ref = "spellChecker"/>
   </bean>

   <!-- Definition for spellChecker bean -->
   <bean id = "spellChecker" class = "com.tutorialspoint.SpellChecker"></bean>

</beans>
```