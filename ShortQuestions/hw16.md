1. List all of the new learned annotations to your annotations.md 

2. what is selenium(YouTube)?

   Selenium is an open-source, automated testing tool used to test web applications across multiple browsers.

   The automation of this testing can be done directly with *Selenium* by *simulating user* expected *behaviour*.

   Dependency in maven.

3. what is cucumber(youtueb)?

   Cucumber is a testing tool that supports Behavior Driven Development (BDD)

   Can be added as plugin in idea.

   it is written in the "Given, When and Then" format

4. what is JMeter(youtube)?

   JMeter is a testing tool used for analyzing and measuring the performance of different software services and products.
   It is used to perform performance testing, functional testing, and load testing of web applications.

5. what is unit-test?

   Unit testing involves the testing of each unit or an individual component of the software application.
   The purpose is to validate that each unit of the software code performs as expected.
   Unit testing is done during develpment of an application by the developers
   Unit may be a anindividual function, method, procedure, module and object.

6. What is the lifecircle of Junit?

   The complete lifecycle of a test case can be seen in three phases with the help of annotations.

   Setup: 
   - This phase puts the the test infrastructure in place. 
   - JUnit provides class level setup (@BeforeAll) and method level setup (@BeforeEach). 
   - Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.

   Test Execution: 
   - In this phase, the test execution and assertion happen. 
   - The execution result will signify a success or failure.

   Cleanup: 
   - This phase is used to cleanup the test infrastructure setup in the first phase. 
   - Just like setup, teardown also happen at class level (@AfterAll) and method level (@AfterEach).

7. Is @BeforeAll method should be Class level(static)? 

   Yes.
   @BeforeAll and @AfterAll annotations should be called only once in the entire tests execution cycle. 
   So they must be declared static at class level. This is because when creating a new test instance per test method, there is no shared state otherwise.

8. What is Mockito? and what is its limitations?

   Mockito is a mocking framework, JAVA-based library that is used for effective unit testing of JAVA applications. Mockito is used to mock interfaces so that a dummy functionality can be added to a mock interface that can be used in unit testing.

   - It cannot mock constructors or static methods.

   - It requires Java version 6 plus to run.
   - It also cannot mock equals(), hashCode() methods.
   - VM mocking is only possible on VMs that are supported by Objenesis.

9. What is @Mock and what is @InjectMocks?

   @Mock is used to create mocks that are needed to support the testing of the class to be tested. 
   @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock annotations into this instance.

10. What is the stubbing?

    Stubbing, like mocking, means creating a stand-in, but a stub only mocks the behavior, but not the entire object. This is used when your implementation only interacts with a certain behavior of the object.

11. what is Mockito ArgumentMatchers

    Argument matchers are mainly used for performing flexible verification and stubbing in Mockito. 
    It extends ArgumentMatchers class to access all the matcher functions. 
    Mockito uses equal() as a legacy method for verification and matching of argument values. 
    In some cases, we need more flexibility during the verification of argument values, so we should use argument matchers instead of equal() method. 

    One option is to return a fixed value:

    ```java
    doReturn("Flower").when(flowerService).analyze("poppy");
    ```

    configure our mocked methods with **argument matchers**:

    ```java
    when(flowerService.analyze(anyString())).thenReturn("Flower");
    ```

    

12. what is Hamcrest Matchers

    Hamcrest is a framework that assists writing software tests in  Java
    It supports creating customized assertion matchers ('Hamcrest' is an anagram of 'matchers'), allowing match rules to be defined declaratively.

    e.g.

    ```java
    List<Integer> num = Arrays.asList(99,123,45,148,33);  
              
    assertThat( num, hasSize(5));  
    assertThat( num, hasItems(99,45));  
    
    assertThat( num, everyItem(greaterThan(20)));  
    assertThat( num, everyItem(greaterThanOrEqualTo(33)));  
    assertThat( num, everyItem(lessThan(150)));  
    ```

    

13. do you know @spy? what is difference between @spy and @Mock? 

    **A spy in mockito is a partial mock** in other mocking frameworks (part of the object will be mocked and part will use real method invocations).

    ```java
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.mockito.Mock;
    import org.mockito.Spy;
    import org.mockito.runners.MockitoJUnitRunner;
     
    import java.util.ArrayList;
    import java.util.List;
     
    import static org.junit.Assert.assertEquals;
    import static org.junit.Assert.assertNull;
    import static org.mockito.Mockito.doReturn;
    import static org.mockito.Mockito.when;
    
    @RunWith(MockitoJUnitRunner.class)
    public class MockSpy {
     
        @Mock
        private List<String> mockList;
     
        @Spy
        private List<String> spyList = new ArrayList();
     
        @Test
        public void testMockList() {
            //by default, calling the methods of mock object will do nothing
            mockList.add("test");
    
            Mockito.verify(mockList).add("test");
            assertEquals(0, mockList.size());
            assertNull(mockList.get(0));
        }
     
        @Test
        public void testSpyList() {
            //spy object will call the real method when not stub
            spyList.add("test");
    
            Mockito.verify(spyList).add("test");
            assertEquals(1, spyList.size());
            assertEquals("test", spyList.get(0));
        }
     
        @Test
        public void testMockWithStub() {
            //try stubbing a method
            String expected = "Mock 100";
            when(mockList.get(100)).thenReturn(expected);
     
            assertEquals(expected, mockList.get(100));
        }
     
        @Test
        public void testSpyWithStub() {
            //stubbing a spy method will result the same as the mock object
            String expected = "Spy 100";
            //take note of using doReturn instead of when
            doReturn(expected).when(spyList).get(100);
     
            assertEquals(expected, spyList.get(100));
        }
    }
    ```

    

14. briefly reading this articles

    1. https://www.javatpoint.com/examples-of-mockito-and-junit-in-eclipse-ide
    2. https://www.javatpoint.com/junit-tutorial
    3. https://www.javatpoint.com/testng-tutorial
    4. https://www.javatpoint.com/jmeter-tutorial