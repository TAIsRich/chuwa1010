# hw42

1. *what is JPA? and what is Hibernate?*
    
    A JPA (Java Persistence API) is a specification of Java which is used to access, manage, and persist data between Java object and relational database. It is considered as a standard approach for Object Relational Mapping.
    
    JPA can be seen as a bridge between object-oriented domain models and relational database systems. Being a specification, JPA doesn't perform any operation by itself. Thus, it requires implementation. So, ORM tools like Hibernate, TopLink, and iBatis implements JPA specifications for data persistence.
    
    A Hibernate is a Java framework which is used to store the Java objects in the relational database system. It is an open-source, lightweight, ORM (Object Relational Mapping) tool.
    
    Hibernate is an implementation of JPA. So, it follows the common standards provided by the JPA.
    
2. *What is Hiraki? what is the benefits of connection pool?*

Hiraki is a connection pooling.

Thread Pool can help us avoid frequent creating and destroying threads.

6.*What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.*

It’s annotations to indicate the data relationships of mapped entities with JPA.   

![Untitled](hw42%2070b8573c64e641708501b191e8dcc953/Untitled.png)

***@OneToMany*** : In the examaple, this would be a `Teacher,` and their `Courses.` A teacher can give multiple courses, but a course is given by only one teacher (that's the *Many-to-One*
 perspective - many courses to one teacher).

@OneToMany

@JoinColumn(name = "TEACHER_ID", referencedColumnName = "ID")

private List<Course> courses;

***ManyToOne*** is just opposite to OneToMany to show the relationships in the opposite way, having the same meanings.

@ManyToOne

@JoinColumn(name = "TEACHER_ID", referencedColumnName = "ID")

private Teacher teacher;

they’re the opposite sides of the same coin.

***ManyToMany***: 

the *Many-to-Many* relationship will be the one between `Student` and `Course` instances as a student can attend multiple courses, and a course can be followed by multiple students.

In order to map a *Many-to-Many* relationship we’ll use the `@ManyToMany` annotation. However, this time around, we'll also be using a `@JoinTable` annotation to set up the table that represents the relationship:

*7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what*
*are the other CascadeType and their features? In which situation we choose*
*which one?*

There we wanted to save the mapped entities whenever the relationship owner entity gets saved. To enable this behavior, we use CascadeType attribute. 

JPA 2 supports an additional and more aggressive remove cascading mode which can be specified using the orphanRemoval element of the @OneToOne and @OneToMany annotations:

```
@Entity
class Employee {
     :
    @OneToOne(orphanRemoval=true)
    private Address address;
     :
}
```

If **orphanRemoval=true** is specified the disconnected Address instance is automatically removed. This is useful for cleaning up dependent objects (e.g. Address) that should not exist without a reference from an owner object (e.g. Employee).

**Other CascadeType:**

1. **CascadeType.PERSIST** : cascade type `presist` means that save() or persist() operations cascade to related entities.
2. **CascadeType.MERGE** : cascade type `merge` means that related entities are merged when the owning entity is merged.
3. **CascadeType.REFRESH** : cascade type `refresh` does the same thing for the refresh() operation.
4. **CascadeType.REMOVE** : cascade type `remove` removes all related entities association with this setting when the owning entity is deleted.
5. **CascadeType.DETACH** : cascade type `detach` detaches all related entities if a “manual detach” occurs.
6. **CascadeType.ALL** : cascade type `all` is shorthand for all of the above cascade operations.

*8. What is the fetch = FetchType.LAZY, fech = FetchType.EAGER? what is the*
*difference? In which situation you choose which one?*

EAGER loading of collections means that they are fetched fully at the time their parent is fetched. So if you have Course and it has List<Student>, all the students are fetched *from the database* at the time the Course is fetched.

LAZY on the other hand means that the contents of the List are fetched only when you try to access them. For example, by calling course.getStudents().iterator(). Calling any access method on the List will initiate a call to the database to retrieve the elements. This is implemented by creating a Proxy around the List (or Set). So for your lazy collections, the concrete types are not ArrayList and HashSet, but PersistentSet and PersistentList (or PersistentBag)

1. *What is the rule of JPA naming convention? Shall we implement the method by*
*ourselves? Could you list some examples?*

The JPA default table name is the name of the class (minus the package) with the first letter capitalized. Each attribute of the class will be stored in a column in the table.

```java
@Entity
public class Person {
    @Id
    private Long id;
    private String firstName;
    private String lastName;
}

create table person (id bigint not null, first_name varchar(255), last_name varchar(255), primary key (id));

## *And a selection query returning all first names would be:*

select first_name from person;
```

Spring implemented its version of the [Hibernate's *PhysicalNamingStrategy*](https://www.baeldung.com/hibernate-naming-strategy):  *[SpringPhysicalNamingStrategy](https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/orm/jpa/hibernate/SpringImplicitNamingStrategy.java)*.

Yes, you can implement the method by custom. We'd need to **provide an implementation of *PhysicalNamingStrategy***. As we're going to keep to snake case, the fastest option is to inherit from the *SpringPhysicalNamingStrategy*
 and turn identifiers to upper case by example : 

```java
public class UpperCaseNamingStrategy extends SpringPhysicalNamingStrategy {
    @Override
    protected Identifier getIdentifier(String name, boolean quoted, JdbcEnvironment jdbcEnvironment) {
        return new Identifier(name.toUpperCase(), quoted);
    }
}
```

just overriding the *getIdentifier()* method, which is in charge of turning the identifiers to lower case in the super-class. Here we're using it to convert them to upper case.  Then done by setting the *spring.jpa.hibernate.naming.physical-strategy* property  in our *application.properties*

Now, our queries are using upper case identifiers:

```sql
create table PERSON (ID bigint not null, FIRST_NAME varchar(255), LAST_NAME varchar(255), primary key (ID));

select FIRST_NAME from PERSON;
```

1. *Try to use JPA advanced methods in your class project. In the repository layer,*
*you need to use the naming convention to use the method provided by JPA.*

1. *Check out a new branch(https://github.com/TAIsRich/springboot-redbook/tree/h*
*w02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao layer using*
*JdbcTemplate.*

###