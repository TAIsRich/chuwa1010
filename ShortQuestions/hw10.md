**3**

JPQL is Java Persistence Query Language defined in JPA specification. It is used to create queries against entities to store in a relational database. JPQL is developed based on SQL syntax. But it won’t affect the database directly. JPQL can retrieve information or data using SELECT clause, can do bulk updates using UPDATE clause and DELETE clause. EntityManager.createQuery() API will support for querying language.

**4**

@NamedQuery: Specifies a static, named query in the Java Persistence query language(JPQL). Query names are scoped to the persistence unit. The NamedQuery annotation can be applied to an entity or mapped superclass.

@NamedQueries: consists of multiple @NamedQuery.


```Java
@NamedQuery(name = "User.findByEmailAddress", query = "select u from User u where u.emailAddress = ?1")
@NamedQueries(value = {
    @NamedQuery(name = "User.findByLastname", query = "select u from User u where u.lastname = ?1")
})
```

**5**

@Query: In order to define SQL to execute for a Spring Data repository method, its value attribute contains the JPQL or SQL to execute. The @Query annotation takes precedence over named queries, which are annotated with @NamedQuery or defined in an orm.xml file.

: for SQL variables

Using SQL or JPQL in repository interface.

**6**

HQL：Hibernate Query Language, HQL queries are translated by Hibernate into conventional SQL queries, which in turns perform action on database.

Criteria Queries:  lets us build nested, structured query expressions in Java, providing a compile-time syntax checking that is not possible with a query language like HQL or SQL.

E:
```Java
Session session = HibernateUtil.getHibernateSession();
CriteriaBuilder cb = session.getCriteriaBuilder();
CriteriaQuery<Item> cr = cb.createQuery(Item.class);
Root<Item> root = cr.from(Item.class);
cr.select(root);

```

**7**

EntiryMangager: manages connection to a database as well as to database operations. All operations on the
entity go through the EntityManager.mark it with the @PersistenceContext annotation and must use @Transactional since the operation should be atomic.
could merge, flush, persist.....


**8**

SessionFactory: SessionFactory is a factory class for Session objects. It is available for the whole application while a Session is only available for particular transaction. It is immutable and thread-safe in nature.

Session: managing HTTP sessions.

**9**

Transaction: represents a unit of work. if one step fails, the whole transaction fails (which is termed as atomicity). A transaction can be described by ACID properties(atomicity, consistency, isolation, and durability.).

It could be managed by using methods like commit() , rollback().

**10**

hibernate Caching: It provides two level cache. The first level is session specific, no query fired and have old values. Two sessions work on the same object, one in charge of updating and saving another but would not affect the first session cache.

**11**

the difference between first-level cache and second-level cache:

first-level is mandatory and all requests should pass while the second-level cache is optional. The first-level stays in session level and its purpose is minimizing database visit. The second-level stays in sessionFactory and its purpose is to cross session use.

priority: first-level cache > second-level cache > database