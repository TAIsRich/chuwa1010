# hw43

1. *List all of the annotations you learned from class and homework to annotaitons.md*

*2. What is Spring and Springboot? What is the benfits of using Srpingboot?*

Simply put, the Spring framework provides comprehensive infrastructure support for developing Java applications. 

Spring Boot is an open-source tool that makes it easier for developers to create standalone digital products and production-ready spring applications including Java applications and web services. It uses a micro framework, which makes it most useful for creating microservices for websites and mobile apps.

*3. What is IOC and What is DI?*

   Inversion of Control (IoC) , IoC is also known as *dependency injection* (DI). It is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then *injects* those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name *Inversion of Control* (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the *Service Locator* pattern.

   Spring IoC (Inversion of Control) Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. The Container uses Dependency Injection(DI) to manage the components that make up the application. It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans. Since the Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control. 

    Dependency Injection is the main functionality provided by Spring IOC(Inversion of Control). The Spring-Core module is responsible for injecting dependencies through either Constructor or Setter methods. The design principle of Inversion of Control emphasizes keeping the Java classes independent of each other and the container frees them from object creation and maintenance. These classes, managed by Spring, must adhere to the standard definition of Java-Bean. Dependency Injection in Spring also ensures loose coupling between the classes.  

*4. What is @CompnonentScan?*

Define where the spring need to scan the bean definations and generate the beans

*5. How to define which package spring need to scan in xml and annotaiton?*

Using @ComponentScan before the class method, to define the package.

*6. What is @SpringbootApplication?*

@SpringBootApplication is a newer version of @EnableAutoConfiguration** which was introduced in Spring Boot 1.2. Actually the `[@SpringBootApplication](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/SpringBootApplication.html)` annotation is equivalent to using `[@Configuration](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html)`, `[@EnableAutoConfiguration](http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html)` and `[@ComponentScan](http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html)` with their default attributes.

*7. How many ways we can define a bean?*

1. Class level, using annotations like @Service @Repository @Component @Controller, @ControllerAdvice 
2. Method level, using @bean annotations **@Bean* *(**used with* *@Configuration**)* *together*
3. define bean in the XML, e.g.

```xml
<bean id="dataNucleusChuwaNoComponent"
class="com.chuwa.springbasic.components.impl.DataNucleusChuwaNoComponent">
</bean>
```

*8. What is default bean name for @Component and @Bean?*

    The default bean name will be method name. 

It means first bean name is getBeanA and second bean name is getBeanB . A bean can be accessed by bean class or bean name or can be injected in component using @Autowired annotation. 

```xml
@Configuration
public class AppConfig {
	@Bean
	public BeanA getBeanA() {
		BeanA beanA = new BeanA();
		beanA.setName("Bean A");
		return beanA;
	}
	@Bean
	public BeanB getBeanB() {
		return new BeanB("Bean B");
	}	
}
```

9 . *What is the difference between @component and @service,@repository?*

 @Component is a generic stereotype for any Spring-managed component. @Service annotates classes at the service layer. @Repository annotates classes at the persistence layer, which will act as a database repository.

*10. How many annotaitons we can use to inject the bean?*

*@Autowired*

*By Type > By Name*

*@Resource*

*By Name > By Type*

*@Inject*

*11.  Tell me the three types to do dependency injection(How can we inject the beans*
*in Spring)? Which way is better and why?*

Constructor Injection
Setter Injection
Field Injection

 Constructor Injection is better because it’s safer.

*12. If we have multiple beans for one type, how to set one is primary? and how to let*
*the spring to pick one bean to inject if no primay.*

A: @Primary Indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency. If exactly one 'primary' bean exists among the candidates, it will be the autowired value.

Using the Qualifier annotation, you clearly mark your intention to inject a specific bean from the context by finding the matched name.

*13. What is the difference between BeanFactory and ApplicationContext in Spring?*

**BeanFactory(I)** – Available in org.springframework.beans.factory package.  **ApplicationContext(I)** – Available in rg.springframework.context package.

**The BeanFactory Interface** is the root interface for accessing a Spring bean container. It is the actual container that instantiates, configures, and manages a number of beans. These beans collaborate with one another and thus have dependencies between themselves. These dependencies are reflected in the configuration data used by the BeanFactory. This interface is implemented by the objects that hold a number of bean definitions, each uniquely identified by a String name. The most common implementation class used for this BeanFactory is XmlBeanFactory available in org.springframework.beans.factory.xml package.

 **ApplicationContext** : This interface is designed on top of the BeanFactory interface. The ApplicationContext interface is the advanced container that enhances BeanFactory functionality in a more framework-oriented style. While the BeanFactory provides basic functionality for managing and manipulating beans, often in a programmatic way, the ApplicationContext provides extra functionality like MessageSource, Access to resources, Event propagation to beans, Loading of multiple (hierarchical) contexts etc. There are so many implementation classes that can be used such as ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, AnnotationConfigWebApplicationContext etc.

To better understand : 

| BeanFactory | ApplicationContext |
| --- | --- |
| It is a fundamental container that provides the basic functionality for managing beans. | It is an advanced container that extends the BeanFactory that provides all basic functionality and adds some advanced features. |
| It is suitable to build standalone applications. | It is suitable to build Web applications, integration with AOP modules, ORM and distributed applications. |
| It supports only Singleton and Prototype bean scopes. | It supports all types of bean scopes such as Singleton, Prototype, Request, Session etc. |
| It does not support Annotations. In Bean Autowiring, we need to configure the properties in XML file only. | It supports Annotation based configuration in Bean Autowiring. |
| This interface does not provides messaging (i18n or internationalization) functionality. | ApplicationContext interface extends MessageSource interface, thus it provides messaging (i18n or internationalization) functionality. |
| BeanFactory does not support Event publication functionality. | Event handling in the ApplicationContext is provided through the ApplicationEvent class and ApplicationListener interface. |
| In BeanFactory, we need to manually register BeanPostProcessors and BeanFactoryPostProcessors. | The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup. |
| BeanFactory will create a bean object when the getBean() method is called thus making it Lazy initialization. | ApplicationContext loads all the beans and creates objects at the time of startup only thus making it Eager initialization. |
| BeanFactory interface provides basic features only thus requires less memory. For standalone applications where the basic features are enough and when memory consumption is critical, we can use BeanFactory. | ApplicationContext provides all the basic features and advanced features, including several that are geared towards enterprise applications thus requires more memory. |

*14. What is the Scope of a Bean? and list the examples for each scope.*

You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition, but also the *scope* of the objects created from a particular bean definition. This approach is very powerful and gives you the flexibility to *choose* the scope of the objects you create through configuration instead of having to 'bake in' the scope of an object at the Java class level. Beans can be defined to be deployed in one of a number of scopes: out of the box, the Spring Framework supports exactly five scopes (of which three are available only if you are using a webaware `ApplicationContext)`

| Scope | Description |
| --- | --- |
| singleton | Scopes a single bean definition to a single object instance per Spring IoC container. |
| prototype | Scopes a single bean definition to any number of object instances. |
| request | Scopes a single bean definition to the lifecycle of a single HTTP request; that is each and every HTTP request will have its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. |
| session | Scopes a single bean definition to the lifecycle of a HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. |
| global session | Scopes a single bean definition to the lifecycle of a global HTTP Session. Typically only valid when used in a portlet context. Only valid in the context of a web-aware Spring ApplicationContext. |

*15. Configure a bean using xml. If bean has parameters/dependencies, how can we*
*configure the bean? (you can google the tutorial how to configure beans in xml,*
*and feel free to ask me any quesitons if you don't understand. it is a little bit old,*
*I am not sure if I need to exaplain it in class)*

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

        <context:component-scan base-package="com.chuwa.springbasic"/>
        <bean id="dataNucleusChuwaNoComponent"  class="com.chuwa.springbasic.components.impl.DataNucleusChuwaNoComponent"></bean>

</beans>
```