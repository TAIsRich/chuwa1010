# hw24

*1. Explain volatile variables in java? (we also use it in Singleton)*

    For Java, “volatile” tells the compiler that the value of a variable must never be cached as its value may change outside of the scope of the program itself. So it can be used to to modify the value of a variable by different threads. It is also used to make classes thread safe. It means that multiple threads can use a method and instance of the classes at the same time without any problem. The volatile keyword can be used either with primitive type or objects.

*2. how to create a new thread(Please also consider Thread Pool case)?*

1. *Extends Thread Class*
2. *Implements Runnable*
3. *Implements Callable*

*3. Difference between Runnable and Callable*

runnable has no return;
callable has return;

*4. what is the diff between t.start() and t.run()?*

t.start starts **a new thread** to excute the task（run()）
t.run() excute the task in the current thread.

*5. Which way of creating threads is better: Thread class or Runnable interface?*

Thread class, because in runnable interface, there is only a method run(), so the thread created by implementing runnable interface is not a complete thread which has other important methods.

*6. what is the thread status?*

初始(NEW)：新创建了⼀个线程对象，但还没有调⽤start()⽅法。
运⾏(RUNNABLE)：Java线程中将就绪（ready）和运⾏中（running）两种状态
笼统的称为“运⾏”。线程对象创建后，其他线程(⽐如main线程）调⽤了该对象的
start()⽅法。该状态的线程位于可运⾏线程池中，等待被线程调度选中，获取CPU
的使⽤权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间⽚后变
为运⾏中状态（running）。
阻塞(BLOCKED)：表⽰线程阻塞于锁。
等待(WAITING)：进⼊该状态的线程需要等待其他线程做出⼀些特定动作（通知
或中断）。
超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后
⾃⾏返回。
终⽌(TERMINATED)：表⽰该线程已经执⾏完毕。

*7. difference between wait() and sleep() method*

The major difference is that wait() releases the lock while sleep() doesn't release any lock while waiting. wait() is used for inter-thread communication while sleep() is used to introduce a pause on execution, generally.

*8. What is deadlock?*

It is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process.

*9. How do threads communicate with each other?*

1. wait()

This method causes the current thread to **release the lock**. This is done until a specific amount of time has passed or another thread calls the **notify()** or **notifyAll()** method for this object.

1. notify()

This method **wakes a single thread** out of multiple threads on the current object’s monitor. The choice of thread is arbitrary.

1. notifyAll()

This method **wakes up all the threads** that are on the current object’s monitor.

1. *what is join() method?*
    
    Join method in Java allows one thread to wait until another thread completes its execution. In simpler words, it means it waits for the other thread to die. It has a ***void*** type and throws ***InterruptedException***.  
    
2. W*hat is yield() method*
    
    A **yield()** method is a **static** method of **Thread** class and it can stop the currently executing thread and will give a chance to **other waiting threads of the same priority.** If in case there are no waiting threads or if all the waiting threads have **low priority** then the same thread will continue its execution. The advantage of **yield()** method is to get a chance to execute other waiting threads so if our current thread takes more time to execute and allocate processor to other threads.
    
3. *Explain thread pool*
    
    In Java, threads are mapped to system-level threads, which are the operating system's resources. If we create threads uncontrollably, we may run out of these resources quickly.
    
    The operating system does the context switching between threads as well — in order to emulate parallelism. A simplistic view is that the more threads we spawn, the less time each thread spends doing actual work.
    
    The Thread Pool pattern helps to save resources in a multithreaded application and to contain the parallelism in certain predefined limits.
    
    When we use a thread pool, we **write our concurrent code in the form of parallel tasks and submit them for execution to an instance of a thread pool.** This instance controls several re-used threads for executing these tasks.
    
    ![threadPool.jpeg](hw24%208e72e97c559e499da57afaf325fd741a/threadPool.jpeg)
    

 **
*13. What is Executor Framework in Java, its different types and how to create these*
*executors?*

Java executor framework is used to run the Runnable objects without creating new threads every time and mostly re-using the already created threads.  

**Executor 1:** SingleThreadExecutor 

`ExecutorService executor = Executors.newSingleThreadExecutor();`

**Executor 2:** FixedThreadPool(n)

As the name indicates, it is a thread pool of a fixed number of threads. The tasks submitted to the executor are executed by the n threads and if there is more task they are stored on a LinkedBlockingQueue. It uses Blocking Queue.

**Syntax:**

```
ExecutorService fixedPool = Executors.newFixedThreadPool(2);
```

**Executor 3:** CachedThreadPool

Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. 

**Executor 4:** ScheduledExecutor

`ScheduledExecutorService scheduledExecService = Executors.newScheduledThreadPool(1);`

*14. Difference between shutdown() and shutdownNow() methods of executor*

Two different methods are provided for shutting down an ExecutorService. The shutdown() method will allow previously submitted tasks to execute before terminating, while the shutdownNow() method prevents waiting tasks from starting and attempts to stop currently executing tasks.

*15. What is Atomic classes? when do we use it?*

*原⼦操作实现了⽆锁的线程安全；适⽤于计数器，累加器等。*

*16. What is the cocurrent collections?*

thread-safe collections. 

*INTERFACE NON-THREAD-SAFE           THREAD-SAFE*
*List                  ArrayList                           CopyOnWriteArrayList*
*Map                HashMap                          ConcurrentHashMap*
*Set                  HashSet / TreeSet             CopyOnWriteArraySet*
*Queue           ArrayDeque / LinkedList ArrayBlockingQueue / LinkedBlockingQueue*
*Deque           ArrayDeque / LinkedList LinkedBlockingDeque*

*17. what kind of locks you know?*

*ReentrantLock*

*ReadWriteLock*

*StampedLock*

*18. What is the difference between class lock and object lock?*

*synchronized关键字⽤于加锁，但这种锁⼀是很重，⼆是获取时必须⼀直等待，没有额外的尝试机制*

*19. What is future and completableFuture?*

*runnable 没有返回值，callable有返回值。并且Callable接⼜是⼀个泛型接⼜，可以返回*
*指定类型的结果。 如何获得异步执⾏的结果？*
 

*当我们提交⼀个Callable任务后，我们会同时获得⼀个Future对象，然后，我们在主线程*

*某个时刻调⽤Future对象的get()⽅法，就可以获得异步执⾏的结果。*

*20. what is ThreadLocal?*

Java标准库提供了一个特殊的`ThreadLocal`，它可以在一个线程中传递同一个对象。

`ThreadLocal`实例通常总是以静态字段初始化如下：

```
static ThreadLocal<User> threadLocalUser = new ThreadLocal<>();
```

*23. write a code to create 2 threads, one thread print 1,3,5,7,9, another thread print*
*2,4,6,8,10.  a. One solution use synchronized and wait notify*
*b. One solution use ReentrantLock and await, signal*

```java
public class OddEventPrinter {
    private static final Object monitor = new Object();
    private static int value = 1;

    public static void main(String[] args) {
        PrintRunnable runnable = new PrintRunnable();
        new Thread(runnable).start();
        new Thread(runnable).start();
    }

    static class PrintRunnable implements Runnable {
        @Override
        public void run() {
            synchronized (monitor) {
                while (value <= 10) {
                    System.out.println(Thread.currentThread().getName() + ": " + value++);
                    monitor.notify();
                    try {
                        monitor.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
		}
}
```

```java
static class PrintRunnable implements Runnable {
        private final Lock lock = new ReentrantLock();
        private final Condition condition = lock.newCondition();

        private int value = 1;
        @Override
        public void run() {

            lock.lock();
            try {
                while (value <= 10) {
                    System.out.println(Thread.currentThread().getName() + ": " + value++);
                    condition.signal();
                    try {
                        condition.await(); // 解锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                lock.unlock();
            }
        }
    }
```

*24. create 3 threads, one thread ouput 1-10, one thread output 11-20, one thread*
*output 21-22. threads run sequence is random. (solution is in*
*com.chuwa.exercise.t08_multithreading.PrintNumber1)*
*Thread-0: 1*
*Thread-1: 2*
*Thread-0: 3*
*Thread-1: 4*
*Thread-0: 5*
*Thread-1: 6*
*Thread-0: 7*
*Thread-1: 8*
*Thread-0: 9*
*Thread-1: 10*
*Process finished with exit code 0*
  

 

```java
public class Q24 {
    private static int n = 1;

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> printNumber());
        Thread t2 = new Thread(() -> printNumber());
        Thread t3 = new Thread(() -> printNumber());

        t1.start();
        t2.start();
        t3.start();
    }

    private static synchronized void printNumber() {
        int count = 10;
        while (count-- > 0) {
            System.out.println(Thread.currentThread().getName() + ": " + n++);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        Q24.class.notifyAll();
    }
}
```