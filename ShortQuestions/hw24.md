1. Explain volatile variables in java? (we also use it in Singleton)  
Volatile tells the compiler that the value of a variable must never be cached as its value may change outside of the scope of the program itself.

2. how to create a new thread(Please also consider Thread Pool case)?
There are three methods to create a new thread:  
First, extends Thread Class:  
```aidl
public class MyThread extends Thread{
    @Override
    public void run() {
    //task
    }
}
Thread t = new MyThread();
t.start();
```
Second, implements Runnable:
```aidl
public class MyRunnable implements Runnable{
    @Override
    public void run() {
    //task
    }
}
Thread t = new Thread(new MyRunnable());
t.start();
```
Third, implements Callable:
```aidl
public class MyCallable implements Callable<String>{
    @Override
    public String call() throws Exception {
    //task
    }
}
Thread t = new Thread(new MyCallable());
t.start();
```
3. Difference between Runnable and Callable  
runnable has no return; callable has return

4. what is the diff between t.start() and t.run()?  
t.start() starts a new thread to excute the task;  
t.run() excute the task in the current thread.

5. Which way of creating threads is better: Thread class or Runnable interface?
It is preferred to implement a Runnable interface instead of extending Thread class.  
As implementing Runnable makes your code loosely coupled as the code of thread is different from the class that assign job to the thread.  
It requires less memory and also allows a class to inherit any other class.

6. what is the thread status?  
* NEW: a new thread object is created, but the start() method has not been called  
* RUNNABLE: the two states of ready and running in a java thread are generally referred to as "running".  
after the thread object is created, other threads (such as the main thread) call the start() method of the object.  
the thread in this state is in the runnable thread pool, waiting to be selected by thread scheduling to obtain the right to use the CPU,
and it is in the ready state at this time.  
a thread in the ready state becomes the running state after obtaining a CPU time slice.  
* BLOCKED: indicates that the thread is blocked on the lock.  
* WAITING: threads entering this state need to wait for other threads to make some specific actions (notifications or interruptions)  
* TIMED_WAITING: this state is different from waiting, it can return by itself after a specified time.  
* TERMINATED: indicates that the thread has finished executing  

7. difference between wait() and sleep() method  
The sleep() method is related to the Thread class that is used to stop the execution of the current thread for few seconds.  
The wait() method is related to the Object class. The thread remains in the waiting state until another thread doesn't invoke the notify() or notifyAll() for that object.  

8. What is deadlock?  
A condition that occurs when two processes are waiting for each other to complete, before proceeding. The result is that both processes wait endlessly.  

9. how do threads communicate with each other?  
syncronized: wait&notify&notifyAll  
ReentrantLock: conditoin.await()&condition.signal()&condition.signalAll()  

10. what is join() method?  
join() method is used to join one thread with the end of the currently running thread.  

11. what is yield() method  
yield() method moves the currently running thread to a runnable state and allows the other threads for execution.
So that equal priority threads have a chance to run. It is a static method. It doesn't release any lock.  

12. Explain thread pool  
A thread pool reuses previously created threads to execute current tasks.
Since the thread already exists when the request arrives, it will eliminate the thread creation time, which will make the program more responsive.  


13. What is Executor Framework in Java, its different types and how to create these
    executors?  
The Executor Framework contains a bunch of components that are used to efficiently manage multiple threads.  

14. Difference between shutdown() and shutdownNow() methods of executor  
shutdown() allow previously submitted tasks to execute before terminating
shutdownNow() prevents waiting tasks from starting and attempts to stop currently executing tasks  

15. What is Atomic classes? when do we use it?
The atomic classes provide a lock-free and thread-safe environment or programming on a single variable.  
It also supports atomic operations.  

16. What is the concurrent collections?  
concurrent collections provide thread-safe collections such as ConcurrentHashMap, CopyOnWriteArrayList, etc.  

17. what kind of locks you know?
ReentrantLock; ReadWriteLock; StampedLock;   

18. What is the difference between class lock and object lock?  
class lock can be used when we want to prevent multiple threads to enter the synchronized block in any of all available instances on runtime.  
object lock can be used when we want non-static method or non-static block of the code should be accessed by only one thread.  

19. What is future and completableFuture?  
Future are basically the placeholders for a result of an operation that has not finished yet. Once the operation finished, the Future will contain that result.  
CompletableFuture implements the Future interface, so we can use it as a Future implementation, but with additional completion logic.  

20. what is ThreadLocal?
ThreadLocal is used to create the thread local variables to avoid synchronization.   

21. Type the code by your self and try to understand it. (package
    com.chuwa.tutorial.t08_multithreading)  

22. Read those interview questions and pick some important questions to this home
    work.  
interview question: https://www.interviewbit.com/multithreading-interview-questions/  

23. write a code to create 2 threads, one thread print 1,3,5,7,9, another thread print
    2,4,6,8,10. (solution is in
    com.chuwa.tutorial.t08_multithreading.c05_waitNotify.OddEventPrinter)
    a. One solution use synchronized and wait notify
    b. One solution use ReentrantLock and await, signal
```aidl
    Thread-0: 1
    Thread-1: 2
    Thread-0: 3
    Thread-1: 4
    Thread-0: 5
    Thread-1: 6
    Thread-0: 7
    Thread-1: 8
    Thread-0: 9
    Thread-1: 10
    Process finished with exit code 0
```
24. create 3 threads, one thread ouput 1-10, one thread output 11-20, one thread
    output 21-22. threads run sequence is random. (solution is in
    com.chuwa.exercise.t08_multithreading.PrintNumber1)
```aidl
    Thread-0: 1
    Thread-0: 2
    Thread-0: 3
    Thread-0: 4
    Thread-0: 5
    Thread-0: 6
    Thread-0: 7
    Thread-0: 8
    Thread-0: 9
    Thread-0: 10
    Thread-2: 11
    Thread-2: 12
    Thread-2: 13
    Thread-2: 14
    Thread-2: 15
    Thread-2: 16
    Thread-2: 17
    Thread-2: 18
    Thread-2: 19
    Thread-2: 20
    Thread-1: 21
    Thread-1: 22
    Thread-1: 23
    Thread-1: 24
    Thread-1: 25
    Thread-1: 26
    Thread-1: 27
    Thread-1: 28
    Thread-1: 29
    Thread-1: 30
```
   
