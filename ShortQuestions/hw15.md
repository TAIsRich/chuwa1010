**2**

selenium: Selenium is an open-source, automated testing tool used to test web applications across various browsers. Selenium can only test web applications, unfortunately, so desktop and mobile apps can’t be tested. However, other tools like Appium and HP’s QTP can be used to test software and mobile applications.

**3**

cucumber: Cucumber testing is a software testing process that deals with an application's behavior. It tests applications as a behavior-driven development (BDD) style. Cucumber tests are written in a simple, natural language that anyone can understand, even people who are not technical experts. 

It helps teams communicate better about the behavior of an application, avoid misunderstandings and reduces the need for lengthy discussions about the code. Moreover, it is easier to change than traditional code-based tests for collaborators. Because they are written in a natural language, they are less likely to break when the code changes. This makes them more flexible and easier to maintain.

**4**

JMeter: The Apache JMeterTM is pure Java open source software, designed to load test functional behavior and measure performance. You can use JMeter to analyze and measure the performance of web application or a variety of services. Performance Testing means testing a web application against heavy load, multiple and concurrent user traffic. JMeter originally is used for testing Web Application or FTP application. Nowadays, it is used for a functional test, database server test etc.

**5**

unit-test: Unit testing is a software testing method where “units”—the individual components of software—are tested. Developers write unit tests for their code to make sure that the code works correctly. This helps to detect and protect against bugs in the future.

**6**

The complete lifecycle of a test case can be seen in three phases with the help of annotations:

Setup: This phase puts the the test infrastructure in place. JUnit provides class level setup (@BeforeAll, for static method) and method level setup (@BeforeEach). Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.

Test Execution: In this phase, the test execution and assertion happen. The execution result will signify a success or failure.

Cleanup: This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, teardown also happen at class level (@AfterAll) and method level (@AfterEach).

**7**

By default, it should be static. But there are also examples that @BeforeAll and @AfterAll lifecycle methods must not be static when declared within a @Nested test class on Java 16.

**8**

Mockito: Mockito is a mocking framework, JAVA-based library that is used for effective unit testing of JAVA applications. It is used to test the functionality of a class in isolation. Mocking does not require a database connection or properties file read or file server read to test a functionality. Mock objects do the mocking of the real service. A mock object returns a dummy data corresponding to some dummy input passed to it.

limitations: It cannot mock constructors or static methods. It requires Java version 6 plus to run. It also cannot mock equals(), hashCode() methods. VM mocking is only possible on VMs that are supported by Objenesis

**9**

@Mock: It is used to mock the objects that helps in minimizing the repetitive mock objects. It makes the test code and verification error easier to read as parameter names (field names) are used to identify the mocks. The @Mock annotation is available in the org. mockito package.

@InjectMocks: creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance.

**10**

stubbing: A stub is a fake class that comes with preprogrammed return values. It's injected into the class under test to give you absolute control over what's being tested as input. A typical stub is a database connection that allows you to mimic any scenario without having a real database.

**11**

Mockito ArgumentMatchers: allow flexible verification or stubbing. 

E:

```Java
 //stubbing using anyInt() argument matcher
 when(mockedList.get(anyInt())).thenReturn("element");

 //following prints "element"
 System.out.println(mockedList.get(999));

 //you can also verify using argument matcher
 verify(mockedList).get(anyInt());

 verify(mock).someMethod(anyInt(), anyString(), eq("third argument"));
 //above is correct - eq() is also an argument matcher

 verify(mock).someMethod(anyInt(), anyString(), "third argument");
 //above is incorrect - exception will be thrown because third argument is given without argument matcher.s
```

**12**

Hamcrest Matchers: Hamcrest is commonly used with junit and other testing frameworks for making assertions. It provides matchers for making assertions on arbitrary Java objects and inspect properties of a Java bean.

E:

```java
 assertThat(person,hasToString(str));

//for bean
 assertThat(person, hasProperty("name"));

//for collections
 assertThat(hamcrestMatchers, hasSize(4));
```

**13**

@spy: A Spy is like a partial mock, which will track the interactions with the object like a mock. Additionally, it allows us to call all the normal methods of the object. Whenever we call a method of the spy object, the real method will be invoked(unless it is stubbed).

difference between @spy and @mock: 

A mock in mockito is a normal mock in other mocking frameworks (allows you to stub invocations; that is, return specific values out of method calls).

A spy in mockito is a partial mock in other mocking frameworks (part of the object will be mocked and part will use real method invocations).